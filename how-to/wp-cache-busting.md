# WordPress: Cache Busting

[üèöÔ∏è](../README.md) | [How To](/how-to/index.md)

To set up cache busting, you can use techniques like appending a version number or a hash to your file names. This ensures that when you update a file, the browser fetches the new version instead of using the cached one. Here are some common methods:

Query Strings: Append a version number or a hash to the file URL. html <link rel="stylesheet" href="style.css?v=1.0"> <script src="script.js?v=1.0"></script>

File Name Versioning: Rename the file with a version number or a hash. html <link rel="stylesheet" href="style.v1.0.css"> <script src="script.v1.0.js"></script>

Build Tools: Use build tools like Webpack, Gulp, or Grunt to automate cache busting by generating unique file names based on content hashes.

## Automate Cache Busting without Build Tools in WordPress

To automate cache busting in WordPress without using build tools, you can use plugins or custom code. Here are a couple of methods:

Using a Plugin:

WP Asset CleanUp: This plugin helps you manage and optimize your CSS and JS files, including cache busting.
Autoptimize: This plugin can aggregate, minify, and cache scripts and styles, and it also includes cache busting features.
Custom Code: You can add a version number to your enqueued scripts and styles in your theme's functions.php file. Here's an example:

```php
function my_theme_enqueue_styles() {
    $theme_version = wp_get_theme()->get('Version');
    wp_enqueue_style('my-theme-style', get_stylesheet_uri(), array(), $theme_version);
    wp_enqueue_script('my-theme-script', get_template_directory_uri() . '/js/script.js', array(), $theme_version, true);
}
add_action('wp_enqueue_scripts', 'my_theme_enqueue_styles');
```

This code will append the theme version to your CSS and JS files, ensuring that the browser fetches the latest version whenever you update your theme.

## Function for Adding Cache Busting to Stylesheet File Path

While the previous section was mostly generated by my ChatGPT prompts, this is WordPress function I created based on my research. Make your **functions.php** look like this:

```php
<?php
/*
 * functions.php
 * 
 */

// Exit if accessed directly
if (!defined('ABSPATH'))
	exit;

/**
 * Enqueue styles
 */
function child_enqueue_styles()
{

	// 08/27/24
	// Makes the style.css URL unique after each child theme update
	//  for CACHE-BUSTING
	$themeVer = wp_get_theme()->get('Version'). "?bust=" . rand(1001, 9999);


	wp_enqueue_style('ehw-astra-child', get_stylesheet_directory_uri() . '/style.css', array('astra-theme-css'), $themeVer, 'all');

}
add_action('wp_enqueue_scripts', 'child_enqueue_styles', 15);

// NOTE: The rest of the "plugins" and custom PHP code should be either in the CUSTOM SITE PLUGIN or Code Snippets
```

Basically, we define a variable `$themeVer` that returns the theme/child theme version and sets the value of a 4-digit random number to a an arbitrary query parameter I called `bust`.

This line defines the theme version variable:

```php
$themeVer = wp_get_theme()->get('Version'). "?bust=" . rand(1001, 9999);
```

Finally, in the second to last parameter in the `wp_enqueue_style()` function, where we usually put `false` by default, this is where we will put `$themeVer`, which will append to the end of `style.css` as a query string, and help with **cache-busting**.

## References

- WPEngine AI Chatbot